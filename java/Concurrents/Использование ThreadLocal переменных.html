<!DOCTYPE html>
<!-- saved from url=(0040)http://articles.javatalks.ru/articles/17 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Использование ThreadLocal переменных</title>
    <link rel="stylesheet" href="./Использование ThreadLocal переменных_files/bootstrap.min.css">
    <link rel="stylesheet" media="screen" href="./Использование ThreadLocal переменных_files/styles.css">
    <link rel="stylesheet" media="screen" href="./Использование ThreadLocal переменных_files/idea.css">
    <link rel="stylesheet" media="screen" href="./Использование ThreadLocal переменных_files/tag-manager.css">
    <link rel="stylesheet" href="./Использование ThreadLocal переменных_files/bootstrap-theme.min.css">
    <link rel="shortcut icon" type="image/png" href="http://articles.javatalks.ru/images/favicon.png">
    <link rel="alternate" type="application/rss+xml" title="RSS subscribtion to JavaTalks Articles" href="http://articles.javatalks.ru/articles/rss">
    
      <link rel="stylesheet" media="screen" href="./Использование ThreadLocal переменных_files/uDIma.css">
    
    
  </head>
  <body>
    <div class="page-wrapper">
      
<nav class="navbar navbar-inverse nav">
  <div class="container"><div class="col-lg-offset-1 col-lg-10 col-md-offset-1 col-md-10 col-sm-12 col-xs-12">
    <ul class="nav navbar-nav brand-container">
      <li>
        <a id="main-rss-link" href="http://articles.javatalks.ru/articles/rss" class="navbar-brand">
          <span>
            <i class="fa fa-rss-square"></i>
          </span>
        </a>
        <a href="http://articles.javatalks.ru/" class="navbar-brand" tabindex="-1">
          <span>
            <i id="application-icon"></i>
            <span id="application-name-container" class="ellipsis-overflow">JavaTalks Articles</span>
          </span>
        </a>
      </li>
    </ul>
    
        <ul class="nav navbar-nav navbar-right">
          <li id="login-links">
            <a href="http://articles.javatalks.ru/signin" tabindex="-1">
              <i class="glyphicon glyphicon-log-in"></i> Sign in
            </a>
            <a href="http://articles.javatalks.ru/signup" tabindex="-1">
              <i class="glyphicon glyphicon-edit"></i> Sign Up
            </a>
          </li>
        </ul>
      
  </div></div>
</nav>
      
      <div class="bb-alert-container">
        <div class="bb-alert alert alert-success center-block" style="display : none">
          <span>Success notification message content</span>
        </div>
        <div class="bb-alert alert alert-danger center-block" style="display : none">
          <span>Error notification message content</span>
        </div>
      </div>
      <div class="container global-block">
        <div class="page-banner col-lg-offset-1 col-lg-10 col-md-offset-1 col-md-10 col-sm-12 col-xs-12">
          <div class="banner-control" style="display : none">
            <div class="input-group">
              <span class="input-group-addon">
                <i class="glyphicon glyphicon-bookmark"></i>
                <a href="http://articles.javatalks.ru/help/administration">Codepen URL</a> for this banner:
              </span>
              <input type="text" class="form-control" placeholder="http://codepen.io/&lt;username&gt;/pen/&lt;id&gt;" value="http://codepen.io/gesser/pen/uDIma">
              <button class="btn btn-default" data-banner-submit-href="/administration/banner/topBanner">
                Apply
              </button>
            </div>
          </div>
          
            <div data-banner-href="http://codepen.io/gesser/pen/uDIma.html"><!-- Google Tag Manager -->
<noscript>&lt;iframe src="//www.googletagmanager.com/ns.html?id=GTM-MZ5PGH"
height="0" width="0" style="display:none;visibility:hidden"&gt;&lt;/iframe&gt;</noscript>

<!-- End Google Tag Manager --></div>
          
        </div>
      </div>
      <div class="container main-container global-block">
        
  <div class="row">
    <div class="col-lg-offset-1 col-lg-10 col-md-offset-1 col-md-10 col-sm-12 col-xs-12">
      <div class="pull-right page-header">
        
        
      </div>
    </div>
  </div>
  <div class="row">
    <div class="col-md-10 col-md-offset-1">
        <div class="share42init pull-right" data-top1="82" data-top2="15" data-margin="20" data-url="http://articles.javatalks.ru/articles/17" data-title="Использование ThreadLocal переменных" data-path="/images/"><span id="share42" style="position: fixed; z-index: 9999; margin-left: 20px; top: 15px;"><span class="share42-item" style="display:block;white-space:no-wrap;margin:0 0 6px;height:24px;"><a rel="nofollow" style="display:inline-block;vertical-align:top;width:24px;height:24px;margin:0;padding:0;outline:none;background:url(/images/icons.png) -0px 0 no-repeat" href="https://www.evernote.com/clip.action?url=http%3A%2F%2Farticles.javatalks.ru%2Farticles%2F17&amp;title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20ThreadLocal%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85" title="Добавить в Evernote" target="_blank"></a></span><span class="share42-item" style="display:block;white-space:no-wrap;margin:0 0 6px;height:24px;"><a rel="nofollow" style="display:inline-block;vertical-align:top;width:24px;height:24px;margin:0;padding:0;outline:none;background:url(/images/icons.png) -24px 0 no-repeat" href="http://articles.javatalks.ru/articles/17#" data-count="fb" onclick="window.open(&#39;http://www.facebook.com/sharer.php?s=100&amp;p[url]=http%3A%2F%2Farticles.javatalks.ru%2Farticles%2F17&amp;p[title]=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20ThreadLocal%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85&amp;p[summary]=&amp;p[images][0]=undefined&#39;, &#39;_blank&#39;, &#39;scrollbars=0, resizable=1, menubar=0, left=100, top=100, width=550, height=440, toolbar=0, status=0&#39;);return false" title="Поделиться в Facebook" target="_blank"></a></span><span class="share42-item" style="display:block;white-space:no-wrap;margin:0 0 6px;height:24px;"><a rel="nofollow" style="display:inline-block;vertical-align:top;width:24px;height:24px;margin:0;padding:0;outline:none;background:url(/images/icons.png) -48px 0 no-repeat" href="http://articles.javatalks.ru/articles/17#" onclick="window.open(&#39;https://plus.google.com/share?url=http%3A%2F%2Farticles.javatalks.ru%2Farticles%2F17&#39;, &#39;_blank&#39;, &#39;scrollbars=0, resizable=1, menubar=0, left=100, top=100, width=550, height=440, toolbar=0, status=0&#39;);return false" title="Поделиться в Google+" target="_blank"></a></span><span class="share42-item" style="display:block;white-space:no-wrap;margin:0 0 6px;height:24px;"><a rel="nofollow" style="display:inline-block;vertical-align:top;width:24px;height:24px;margin:0;padding:0;outline:none;background:url(/images/icons.png) -72px 0 no-repeat" href="http://articles.javatalks.ru/articles/17#" data-count="lnkd" onclick="window.open(&#39;http://www.linkedin.com/shareArticle?mini=true&amp;url=http%3A%2F%2Farticles.javatalks.ru%2Farticles%2F17&amp;title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20ThreadLocal%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85&#39;, &#39;_blank&#39;, &#39;scrollbars=0, resizable=1, menubar=0, left=100, top=100, width=600, height=400, toolbar=0, status=0&#39;);return false" title="Добавить в Linkedin" target="_blank"></a></span><span class="share42-item" style="display:block;white-space:no-wrap;margin:0 0 6px;height:24px;"><a rel="nofollow" style="display:inline-block;vertical-align:top;width:24px;height:24px;margin:0;padding:0;outline:none;background:url(/images/icons.png) -96px 0 no-repeat" href="http://articles.javatalks.ru/articles/17#" data-count="odkl" onclick="window.open(&#39;http://www.odnoklassniki.ru/dk?st.cmd=addShare&amp;st._surl=http%3A%2F%2Farticles.javatalks.ru%2Farticles%2F17&amp;title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20ThreadLocal%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85&#39;, &#39;_blank&#39;, &#39;scrollbars=0, resizable=1, menubar=0, left=100, top=100, width=550, height=440, toolbar=0, status=0&#39;);return false" title="Добавить в Одноклассники" target="_blank"></a></span><span class="share42-item" style="display:block;white-space:no-wrap;margin:0 0 6px;height:24px;"><a rel="nofollow" style="display:inline-block;vertical-align:top;width:24px;height:24px;margin:0;padding:0;outline:none;background:url(/images/icons.png) -120px 0 no-repeat" href="http://articles.javatalks.ru/articles/17#" data-count="twi" onclick="window.open(&#39;https://twitter.com/intent/tweet?text=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20ThreadLocal%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85&amp;url=http%3A%2F%2Farticles.javatalks.ru%2Farticles%2F17&#39;, &#39;_blank&#39;, &#39;scrollbars=0, resizable=1, menubar=0, left=100, top=100, width=550, height=440, toolbar=0, status=0&#39;);return false" title="Добавить в Twitter" target="_blank"></a></span><span class="share42-item" style="display:block;white-space:no-wrap;margin:0 0 6px;height:24px;"><a rel="nofollow" style="display:inline-block;vertical-align:top;width:24px;height:24px;margin:0;padding:0;outline:none;background:url(/images/icons.png) -144px 0 no-repeat" href="http://articles.javatalks.ru/articles/17#" data-count="vk" onclick="window.open(&#39;http://vk.com/share.php?url=http%3A%2F%2Farticles.javatalks.ru%2Farticles%2F17&amp;title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20ThreadLocal%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85&amp;image=undefined&amp;description=&#39;, &#39;_blank&#39;, &#39;scrollbars=0, resizable=1, menubar=0, left=100, top=100, width=550, height=440, toolbar=0, status=0&#39;);return false" title="Поделиться В Контакте" target="_blank"></a></span></span></div>
      <article class="entry">
        <div class="main-content">
          <header>
            
<div class="date">
  <span class="day">08</span>
  <span class="month">Aug</span>
  <span class="year">2013</span>
</div>
            <div class="article-header">
              <h2>Использование ThreadLocal переменных</h2>
              
            </div>
          </header>
          <div class="body">
            <div class="content clearfix"><h2>Введение</h2><p>Вы уже наверно знаете, что поля классов в java бывают статические и не статические. Любое поле класса без модификатора static принадлежит объекту данного класса и создается каждый раз когда создается новый экземпляр класса. Статические переменные(помеченные модификатором static) не принадлежат экземпляру класса и существует всегда в единственном экземпляре независимо от того, сколько экземпляров класса было создано. Появившийся в java 1.2 класс <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/ThreadLocal.html">java.lang.ThreadLocal</a>по сути предоставляет нам ещё одну область жизни объектов, ThreadLocal предоставляет абстракцию над переменными локальными по отношению к потоку испольнения <a href="http://docs.oracle.com/javase/6/docs/api/java.lang.Thread.html">java.lang.Thread</a>. ThreadLocal переменные отличаются от обычных переменных тем, что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной, доступ к которой он получает через методы get() или set().</p><p>Я в своей практике встречался с четырьмя основными целями применения ThreadLocal переменных:<br>1. Упрощение API.<br>2. Cинтаксический сахар.<br>3. Кеширование непотокобезопасных(non thread safe) ресурсов.<br>4. Уменьшение области конкуренции между потоками(lock striping).</p><h2>Упрощение API с помощью ThreadLocal.</h2><p>Допустим Вы разрабатываете JEE веб приложение, после прохождения аутентификации на странице логина информация о пользователе запоминается в http сессии, и Вам в любой точке кода может понадобится информация о пользователе от которого пришел http запрос.<br>Наверняка Вы не захотите всю логику помещать в сервлеты и JSP, Вы выделети в приложение несколько слоев(бизнесс логика, доступ к данным и.т.д.), но после распределния ответсвенности по слоям у Вас может возникнуть проблема с тем, что не в каждой точке кода будет доступ к Http сессии, соответсвенно не везде можно будет узнать от какого пользователя пришел запрос.<br>Встает вопрос? а как проектировать свой API? Добавлять в каждый метод каждого класса дополнительный параметр представляющий данные пользователе? </p><p>До появления ThreadLocal это был единственный выход, с появлением же ThreadLocal мы можем привязать данные о пользователи к потоку обработки http запроса, и достать эту информацию в любом месте программы. Для этого нам понадобится зарегистрировать слушателя в контексте веб приложения который будет срабатывать на любой входящий http запрос:</p><p>Итак начнем с класса для реализации потокобезопсного контеста пользователя:<br>
</p><pre><code class="java hljs "><span class="hljs-keyword">package</span> ru.javatalks;

<span class="hljs-javadoc">/**
 *<span class="hljs-javadoctag"> @author</span> Vermut
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityContextHolder</span> {</span>
	
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;User&gt; threadLocalScope = <span class="hljs-keyword">new</span>  ThreadLocal&lt;&gt;();
	
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">getLoggedUser</span>() {
		<span class="hljs-keyword">return</span> threadLocalScope.get();
	}
	
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoggedUser</span>(User user) {
		threadLocalScope.set(user);
	}

}</code></pre><br>Как мы знаем сервера приложений могут выполнять тысячи запросов одновременно и на первый взгляд такой код не потоко безопасен. Ведь действительно мы запоминаем текущего пользователя в статической переменной, а статическая переменная одна на весь класс, и вроде бы как паралельные http запросы должны перетирать данные друг друга.<br>Но вся фишка ThreadLocal заключается в том что имея всего одну ThreadLocal переменную, мы можем иметь различное значение для каждого из потоков, то есть один поток никогда не прочтет, удалит или не перезатрет данные присвоенные другим потоком. Таким образом несмотря на разделяемую статическую переменную код выше потоко-безопасен.<p></p><p>Хранилище аутентификацционных данных написано, теперь нужно написать и сконфигурировать в web.xml слушателя входящих HTTP запросов, который бы при поступлении запроса присоеденяя данные о пользователе к потоку обработки а по завершении обработки запроса, очищал бы эту информацию.<br>
</p><pre><code class="java hljs "><span class="hljs-keyword">package</span> ru.javatalks;

<span class="hljs-keyword">import</span> javax.servlet.ServletRequestEvent;
<span class="hljs-keyword">import</span> javax.servlet.ServletRequestListener;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;

<span class="hljs-javadoc">/**
 *<span class="hljs-javadoctag"> @author</span> Vermut
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthentificationPropagationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletRequestListener</span> {</span>

	<span class="hljs-annotation">@Override</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestInitialized</span>(ServletRequestEvent event) {
		HttpServletRequest request = (HttpServletRequest) event.getServletRequest();
		HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);
		<span class="hljs-keyword">if</span> (session == <span class="hljs-keyword">null</span>) {
			<span class="hljs-keyword">return</span>;
		}
		User user = (User) session.getAttribute(<span class="hljs-string">"loged_user"</span>);
		SecurityContextHolder.setLoggedUser(user);
	}
	
	<span class="hljs-annotation">@Override</span>
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestDestroyed</span>(ServletRequestEvent event) {
		SecurityContextHolder.setLoggedUser(<span class="hljs-keyword">null</span>);
	}

}</code></pre><br>Дело осталось за малым воспользоваться написаными функционалом из любой точки приложения в которой нет доста к http запросу или сессии:<p></p>
<pre><code class="java hljs "><span class="hljs-keyword">package</span> ru.javatalks;

<span class="hljs-javadoc">/**
 *<span class="hljs-javadoctag"> @author</span> Vermut
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderService</span> {</span>
	
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createOrder</span>(Order order) {
		User user = SecurityContextHolder.getLoggedUser();
		checkEligibility(user, order.getSum());
		order.setUserId(user.getId())
		...
	}

}</code></pre><p>Конечно же функционал реализованный выше редко когда придется писать самому, есть множество библиотек связанных с security в которых это уже реализовано, например spring-security, стоит только иметь в виду что все они будут точно также работать посредством ThreadLocal. Построение API вокруг ThreadLocal широко используется в java enterprise edition и используется не только для ассоциирования контекста безопасности с потоком, но и для других вещей как например транзакции, открытые JPA сессии. Так же хочу заметить что использование ThreadLocal в JEE окружении сопряжено с возникновением многих проблемам и без глубокого понимания платформы jee, многопоточности и механизма загрузки классов от использования ThreadLocal в JEE лучше отказаться. Проблемы порождаемые ThreadLocal переменными в JEE окружении описаны в конце статьи.</p><h2>2. Cинтаксический сахар или программирование на языке.</h2><p>ThreadLocal можно использовть для добавления синтаксического сахара в язык java и многие библиотеки этим пользуются, например mybatis:<br>
</p><pre><code class="java hljs "><span class="hljs-keyword">private</span> String <span class="hljs-title">selectPersonSql</span>() { 
    BEGIN(); <span class="hljs-comment">// Clears ThreadLocal variable </span>
    SELECT(<span class="hljs-string">"P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME"</span>); 
    SELECT(<span class="hljs-string">"P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON"</span>); 
    FROM(<span class="hljs-string">"PERSON P"</span>); 
    FROM(<span class="hljs-string">"ACCOUNT A"</span>); 
    INNER_JOIN(<span class="hljs-string">"DEPARTMENT D on D.ID = P.DEPARTMENT_ID"</span>); 
    INNER_JOIN(<span class="hljs-string">"COMPANY C on D.COMPANY_ID = C.ID"</span>); 
    WHERE(<span class="hljs-string">"P.ID = A.ID"</span>); 
    WHERE(<span class="hljs-string">"P.FIRST_NAME like ?"</span>); 
    OR(); 
    WHERE(<span class="hljs-string">"P.LAST_NAME like ?"</span>); 
    GROUP_BY(<span class="hljs-string">"P.ID"</span>); 
    HAVING(<span class="hljs-string">"P.LAST_NAME like ?"</span>); 
    OR(); 
    HAVING(<span class="hljs-string">"P.FIRST_NAME like ?"</span>); 
    ORDER_BY(<span class="hljs-string">"P.ID"</span>); 
    ORDER_BY(<span class="hljs-string">"P.FULL_NAME"</span>); 
    <span class="hljs-keyword">return</span> SQL(); 
  }</code></pre><br>Код получился легко читаемым, как видно функции BEGIN, SELECT и.т.д. не вызываются ни на одном объекте, то есть они статические и за счет статического импорта появившегося в java 5, вызов таких функций можно осуществлять без префикса класса. Потоко-безопасность достигается за счет того что каждый поток выполнения имеет собственный экземпляр билдера запросов. Конечно следует ожидать, что c появлением лямбд в java 8, использование ThreadLocal в качестве синтаксического сахара потеряет свою актуальность<p></p><h2>Кеширование непотокобезопасных(non thread safe) ресурсов.</h2><p>Однажды делая код ревью одного класса я обнаружил очень интересный баг многопоточности:<br>
</p><pre><code class="java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">XmlAdapter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; {</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"dd.MM.yyyy"</span>);

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">marshal</span>(Date value) <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">return</span> format.format(value);
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> Date <span class="hljs-title">unmarshal</span>(String value) <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">return</span> isNullOrEmpty(value)? <span class="hljs-keyword">null</span>: format.parse(value);  
    }

}</code></pre><br>Класс использовался как кастомный адаптер для даты в JAXB. Вроде бы простой маленьки класс и в нём негде ошибится, однако есть одно но, класс java.text.SimpleDateFormat не является потоко безопасным, параллельные потоки должны либо синхронизировать доступ к инстансу объекта данного класса, либо отказаться от разделения одного инстанса SimpleDateFormat.<br>То есть просто создать один экземпляр формата и запомнить в статической переменной нельзя, иначе мы получим мусор на выходе если форматировать даты паралельно из нескольких потоков. Честно говоря в приложении рассчитаном на входящий поток данных 5 тысяч входящих документов в секунду, ни генерировать мусор создавая каждый раз новый экземпляр формата, ни тем более создавать бутылочное горлышко в виде synchronized блоков мне не хотелось, и поскольку стояло жесткое требование по максимуму отказаться от библиотек не входящих в j2se, то есть нельзя было использовать сторонние реализации форматеров то код выше превратился в следующее:<br>
<pre><code class="java hljs "><span class="hljs-javadoc">/**
 *
 *<span class="hljs-javadoctag"> @author</span> Vermut
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">XmlAdapter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; {</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;DateFormat&gt; THREAD_CACHE = <span class="hljs-keyword">new</span> ThreadLocal&lt;DateFormat&gt; ();

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title">marshal</span>(Date value) <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">return</span> getFormat().format(value);
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> Date <span class="hljs-title">unmarshal</span>(String value) <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">return</span> isNullOrEmpty(value)? <span class="hljs-keyword">null</span>: getFormat().parse(value);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title">getFormat</span>() {
        DateFormat format = THREAD_CACHE.get();
        <span class="hljs-keyword">if</span> (format == <span class="hljs-keyword">null</span>) {
            format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"dd.MM.yyyy"</span>);
            THREAD_CACHE.set(format);
        }
        <span class="hljs-keyword">return</span> format;
    }

}</code></pre><br>Как видно обеспечено кеширование объектов DateFormat без синхронизации. В статье <a href="http://www.javacodegeeks.com/2010/07/java-best-practices-dateformat-in.html">Java Best Practices – DateFormat in a Multithreading Environment</a>приведены результаты бенчмарков показывающих что такой подход позволяет увеличить производительность парсинга дат до 8 раз по сравнению с созданием каждый раз нового экземпляра формата.<p></p><h2>Сужение области конкуренции между потоками(lock striping).</h2><p>Lock striping техника представления сложного объекта, к которому осуществляется конкуретный доступ в виде отдельных маленьких частей, каждую часть такого объекта можно менять без блокировки целого объекта. Например техника lock striping применена в CuncurrentHashMap - вся коллекция разбита на регионы, и треды при модификации не конкурируют за всю коллекцию целиком, они конкурируют за её отдельные регионы, таким образом острота конкуренции снижается.</p><p>Прежде всего для этого параграфа хотелось бы сразу поместить disclaimer и cсылку на эту презентацию<br><a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=aMQJnigGvfY"><img src="./Использование ThreadLocal переменных_files/0.jpg" alt="java8 новинки в java.util.concurrent"></a>, в презентации авторитетные специалисты в области java оптимизации в квалификации которых не возникает ни каких сомнений, крайне не рекомендуют использовать ThreadLocal для сuncurrent оптимизаций. </p><p>Однако пока java8 ещё не зарелизена, а в продакшн энтерпрайз приложений java8 попадет вообще не скоро, то пример использования ThreadLocal я всё же опубликую.</p><p>И так представим высоконагруженное приложение с тысячами рабочих потоков. Потоки занимаются тем что обрабатывают пачки входящих документов и нам бы хотелось собирать некоторую статистику о работе приложения, а конкретно количество обработанных документов. Но при этом мы бы хотели чтобы сбор статистики обходился нам бесплатно, и не вносил бы лишних нагрузку в приложение.<br>Какие сть варианты решения:<br>Выполнять запрос SELECT COUNT(*) FROM TABLE в базу данных - на таких объемах не очень удачное решение.<br>Заводить AtomicLong - поможет на небольшом количестве потоков, но не на тысячах.</p><p>Итак применим ThreadLocal. Общее количество обработанных сервером документов можно представить как сумму обработанных документов каждым рабочим потоком. То есть к каждому треду можно поставить соответсвии число, и он будет увеличивать это число вообще без конкуренции с каким либо другим потоком, то есть как мы и хотели сбор статистики обходится нам бесплатно.<br>
</p><pre><code class="java hljs "><span class="hljs-keyword">package</span> ru.javatalks;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-javadoc">/**
 *<span class="hljs-javadoctag"> @author</span> Vermut
 *
 */</span>
<span class="hljs-keyword">package</span> ru.javatalks;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;

<span class="hljs-javadoc">/**
 *<span class="hljs-javadoctag"> @author</span> Vermut
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalAdder</span> {</span>
	
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;SumContainer&gt; threadLocalScope = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;SumContainer&gt; allThreadSums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock readWriteLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();
	
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-keyword">long</span> value) {
		SumContainer threadLocalSum = threadLocalScope.get();
		<span class="hljs-keyword">if</span> (threadLocalSum == <span class="hljs-keyword">null</span>) {
			threadLocalSum = <span class="hljs-keyword">new</span> SumContainer();
			threadLocalScope.set(threadLocalSum);
			<span class="hljs-comment">/*
			 * Самое первое получение локального блокирует подсчет общей суммы,
			 *  но это критично только пока приложение не войдет в рабочий ритм, 
                          * в    разогнавшемся приложении уже каждый поток хоть раз да проинкрементил свой счетчик.
			 */</span>
			readWriteLock.writeLock().lock();
			<span class="hljs-keyword">try</span> {
				allThreadSums.add(threadLocalSum);
			} <span class="hljs-keyword">finally</span> {
				readWriteLock.writeLock().unlock();
			}
		}
		threadLocalSum.value += value;
	}
	
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getSum</span>() {
		<span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>L;
		<span class="hljs-comment">/*
		 * Как видно подсчет суммы медленная операция, так как сумма не хранится в готовом для чтения виде,
		 * что в принципе вписывается в концепцию lock striping, и не является критичным моментом в данном конкретном случае,
		 * так как админы приложения могут и несколько дней не заглядывать в перфоманс монитор.
		 */</span> 
		readWriteLock.readLock().lock();
		<span class="hljs-keyword">try</span> {
			<span class="hljs-keyword">for</span> (SumContainer threadLocalSum : allThreadSums) {
				sum += threadLocalSum.value;
			}
		} <span class="hljs-keyword">finally</span> {
			readWriteLock.readLock().unlock();
		}
		<span class="hljs-keyword">return</span> sum;
	}
	
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumContainer</span> {</span>
		<span class="hljs-comment">/*
		 * Поле специально не volatile и не атомик, потому что абсолютная точность не нужна,
		 * допустимо чтобы запрос на получение статиcтики не увидел последних инкрементов сделанных рабочим потоком.
		 * Таким образом мы добились чего хотели, сбор статистики сделан бесплатным, его стоимость равна чтению из
		 * обычного (несинхронизированного) хешмапа коим по сути является ThreadLocal
		 */</span>
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> value;
		
	}

}</code></pre><br>Для сокращения кода и упрощения понимания концепции ThreadLocal, из кода удалена обработка ситуаций внезапной смерти потоков. По хорошему нужно обрабатывать ситуацию, когда ThreadLocal собирается сборщиком мусора потому, что поток которому она принадлежит более недостижим из корня, но чтобы не отвлекать внимание читателя в сторону PhantomReference обработка этих ситуаций из кода удалена, а аспекты взаимодействия ThreadLocal и сборки мусора вынесены в отдельный параграф.<p></p><p>А вот небольшой тест показывающий применение такого аккомулятора:<br>
</p><pre><code class="java hljs "><span class="hljs-keyword">package</span> ru.javatalks;

<span class="hljs-javadoc">/**
 *<span class="hljs-javadoctag"> @author</span> Vermut
 *
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalAdderTest</span> {</span>
	
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OBSERVER_SLEEP_TIMEOUT = <span class="hljs-number">1000</span>;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ITERATION_COUNT_PEER_THREAD = <span class="hljs-number">1</span>_000_000_000l;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREAD_COUNT = <span class="hljs-number">10</span>;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> INCREMENT_COUNT = <span class="hljs-number">10</span>;
	
	
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span> InterruptedException {
		ThreadLocalAdder threadLocalAdder = <span class="hljs-keyword">new</span> ThreadLocalAdder();
		AdderThread[] threads = <span class="hljs-keyword">new</span> AdderThread[THREAD_COUNT];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; THREAD_COUNT; i++) {
			threads[i] = <span class="hljs-keyword">new</span> AdderThread(threadLocalAdder);
			threads[i].start();
		}
		<span class="hljs-keyword">int</span> aliveThreadCount = THREAD_COUNT;
		<span class="hljs-keyword">long</span> previousSum = <span class="hljs-number">0</span>l;
		<span class="hljs-keyword">long</span> sum = threadLocalAdder.getSum();
		<span class="hljs-keyword">long</span> sumNotChangedBeetweenIterationCount = <span class="hljs-number">0</span>l;
		<span class="hljs-keyword">long</span> iterationCount = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span> (aliveThreadCount &gt; <span class="hljs-number">0</span>) {
			Thread.sleep(OBSERVER_SLEEP_TIMEOUT);
			iterationCount ++;
			aliveThreadCount = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">for</span> (AdderThread thread : threads) {
				<span class="hljs-keyword">if</span> (thread.isAlive()) {
					aliveThreadCount ++;
				}
			}
			sum = threadLocalAdder.getSum();
			<span class="hljs-keyword">if</span> (previousSum == sum) {
				sumNotChangedBeetweenIterationCount++;
			}
			System.out.println(iterationCount + <span class="hljs-string">" : "</span> + sum + <span class="hljs-string">" : "</span> +  sumNotChangedBeetweenIterationCount);
			previousSum = sum;
		}
		System.out.println(sum == ITERATION_COUNT_PEER_THREAD * THREAD_COUNT * INCREMENT_COUNT);
	}
	
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> {</span>
		
		<span class="hljs-keyword">private</span> ThreadLocalAdder adder;

		<span class="hljs-keyword">public</span> <span class="hljs-title">AdderThread</span>(ThreadLocalAdder adder) {
			<span class="hljs-keyword">this</span>.adder = adder;
		}
		
		<span class="hljs-annotation">@Override</span>
		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; ITERATION_COUNT_PEER_THREAD; i++) {
				adder.add(INCREMENT_COUNT);
			}
		}
	}

}</code></pre><p></p></div>
          </div>
        </div>
        <footer>
          <ul class="footer-elements breadcrumb clearfix">
            <li class="footer-element">
              <i class="glyphicon glyphicon-user"></i>
              <strong>by </strong>
              <a href="http://articles.javatalks.ru/users/Vermut">Vermut</a>
            </li>
              
                
<a href="http://articles.javatalks.ru/articles?tags=threadlocal">
  <span class="pull-right tm-tag tm-tag-default">
    threadlocal
  </span>
</a>
              
          </ul>
        </footer>
      </article>
      <section class="comments">
        <h3 class="comments-header"><b>5</b>Comments</h3>
        
          
            <article class="clearfix comment comment-other">
              <a id="comments"></a>
              <div id="comment25" class="comment-bubble comment-bubble-other">
                <header>
                  <span class="glyphicon glyphicon-user"></span>
                  <a href="http://articles.javatalks.ru/users/wedens">wedens</a>
                  <time class="pull-right" datetime="2013-08-08 05:24">
                    <span class="glyphicon glyphicon-calendar"></span> 08-Aug-2013 05:24
                  </time>
                </header>
                <div class="content clearfix"><p>я вот не совсем понял в чем заключается роль <code>ThreadLocal</code> во внесении синтаксического сахара. или он только обеспечивает потокобезопасность этого сахара?:)</p></div>
              </div>
              <div class="toolb">
              <a id="25" class="btn btn-default btn-xs permalink" title="Get a permanent link to this comment" href="http://articles.javatalks.ru/articles/17#25">
                  <span class="glyphicon glyphicon-link"></span>
              </a>
              
              </div>
            </article>
          
            <article class="clearfix comment comment-other">
              <a id="comments"></a>
              <div id="comment26" class="comment-bubble comment-bubble-other">
                <header>
                  <span class="glyphicon glyphicon-user"></span>
                  <a href="http://articles.javatalks.ru/users/%D0%A1%D1%82%D0%B0%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D1%8A">Староверъ</a>
                  <time class="pull-right" datetime="2013-08-08 05:37">
                    <span class="glyphicon glyphicon-calendar"></span> 08-Aug-2013 05:37
                  </time>
                </header>
                <div class="content clearfix"><p>Отличная статья! Вот только терзают сомнения насчет реализации счетчика - в реальности <code>AtomicInteger</code> вполне бы был достойной альтернативой.</p></div>
              </div>
              <div class="toolb">
              <a id="26" class="btn btn-default btn-xs permalink" title="Get a permanent link to this comment" href="http://articles.javatalks.ru/articles/17#26">
                  <span class="glyphicon glyphicon-link"></span>
              </a>
              
              </div>
            </article>
          
            <article class="clearfix comment comment-other">
              <a id="comments"></a>
              <div id="comment28" class="comment-bubble comment-bubble-other">
                <header>
                  <span class="glyphicon glyphicon-user"></span>
                  <a href="http://articles.javatalks.ru/users/Vermut">Vermut</a>
                  <time class="pull-right" datetime="2013-08-08 06:26">
                    <span class="glyphicon glyphicon-calendar"></span> 08-Aug-2013 06:26
                  </time>
                </header>
                <div class="content clearfix"><blockquote><p>я вот не совсем понял в чем заключается роль ThreadLocal во внесении синтаксического сахара. или он только обеспечивает потокобезопасность этого сахара?:)</p>
</blockquote><p>Ну да, речь конечно же не о том что ThreadLocal предоставляет новый синтаксис, конечно же ThreadLocal просто обеспечивает работоспособность в многопоточной среде, невероятных с(точки зрения ООП) конструкций реализованых в mybatis SqlBuilder.</p></div>
              </div>
              <div class="toolb">
              <a id="28" class="btn btn-default btn-xs permalink" title="Get a permanent link to this comment" href="http://articles.javatalks.ru/articles/17#28">
                  <span class="glyphicon glyphicon-link"></span>
              </a>
              
              </div>
            </article>
          
            <article class="clearfix comment comment-other">
              <a id="comments"></a>
              <div id="comment30" class="comment-bubble comment-bubble-other">
                <header>
                  <span class="glyphicon glyphicon-user"></span>
                  <a href="http://articles.javatalks.ru/users/RodionGork">RodionGork</a>
                  <time class="pull-right" datetime="2013-08-14 08:54">
                    <span class="glyphicon glyphicon-calendar"></span> 14-Aug-2013 08:54
                  </time>
                </header>
                <div class="content clearfix"><p>Эк придираться стали :)</p><p>А мне статья оч понравилась и точно подозреваю что она многим м.б. полезна - т.к. ThreadLocal это вещь которую обычно познают внезапно и не на раннем этапе.</p><p>Можно пожалуй разве что упомянуть что в случае когда мы имеем доступ к созданию тредов - мы могли что-то вроде аналога ThreadLocal делать держа данные в полях треда… Но это имхо слишком узкоспециально (хотя можно наверное использовать если жалко времени на лукап в ThreadLocal).</p><p>В общем, спасибо!</p></div>
              </div>
              <div class="toolb">
              <a id="30" class="btn btn-default btn-xs permalink" title="Get a permanent link to this comment" href="http://articles.javatalks.ru/articles/17#30">
                  <span class="glyphicon glyphicon-link"></span>
              </a>
              
              </div>
            </article>
          
            <article class="clearfix comment comment-other">
              <a id="comments"></a>
              <div id="comment27" class="comment-bubble comment-bubble-other">
                <header>
                  <span class="glyphicon glyphicon-user"></span>
                  <a href="http://articles.javatalks.ru/users/Vermut">Vermut</a>
                  <time class="pull-right" datetime="2014-04-23 08:37">
                    <span class="glyphicon glyphicon-calendar"></span> 23-Apr-2014 08:37
                  </time>
                </header>
                <div class="content clearfix"><blockquote><p>Вот только терзают сомнения насчет реализации счетчика - в реальности AtomicInteger вполне бы был достойной альтернативой.</p>
</blockquote><p>Атомики не очень хороши когда количество параллельных потоков велико, вот например в этой презентации рассказывается как с этим будут бороться в java 8 <a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=aMQJnigGvfY"><img src="./Использование ThreadLocal переменных_files/0.jpg" alt="Новинки в java.util.concurrent c Дмитрием Чуйко"></a>.<br>Один атомик на сервер с несколькими тысячами потоков желающих проинкрементить сумму не очень удачный вариант, хотя конечно если инкрементить скажем общий счетчик к примеру только каждую сотую операцию, то и решение с одним атомиком подойдёт.</p></div>
              </div>
              <div class="toolb">
              <a id="27" class="btn btn-default btn-xs permalink" title="Get a permanent link to this comment" href="http://articles.javatalks.ru/articles/17#27">
                  <span class="glyphicon glyphicon-link"></span>
              </a>
              
              </div>
            </article>
          
        
        
      </section>
    </div>
  </div>

        <div class="page-banner col-lg-offset-1 col-lg-8 col-md-offset-1 col-md-8 col-sm-12 col-xs-12">
          <div class="banner-control" style="display : none">
            <div class="input-group">
              <span class="input-group-addon">
                <i class="glyphicon glyphicon-bookmark"></i>
                <a href="http://articles.javatalks.ru/help/administration">Codepen URL</a> for this banner:
              </span>
              <input type="text" class="form-control" placeholder="http://codepen.io/&lt;username&gt;/pen/&lt;id&gt;">
              <button class="btn btn-default" data-banner-submit-href="/administration/banner/bottomBanner">
              Apply
              </button>
            </div>
          </div>
          
        </div>
      </div>
      <footer class="footer">
        <div class="col-lg-offset-1 col-lg-10 col-md-offset-1 col-md-10 col-sm-12 col-xs-12 global-block">
          <span class="pull-left">
            Powered by Antarcticle 2.8.622.6e8c99f
          </span>
          <span class="pull-right">
            <i class="icon-cogs"></i>
            Based on <a tabindex="-1" href="http://twitter.github.com/bootstrap/">Twitter Bootstrap</a>
          </span>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" async="" src="./Использование ThreadLocal переменных_files/analytics.js"></script><script async="" src="./Использование ThreadLocal переменных_files/gtm.js"></script><script src="./Использование ThreadLocal переменных_files/jquery.min.js" type="text/javascript"></script>
    <script src="./Использование ThreadLocal переменных_files/bootstrap.min.js" type="text/javascript"></script>
    <script src="./Использование ThreadLocal переменных_files/Global.js" type="text/javascript"></script>
    <script src="./Использование ThreadLocal переменных_files/NotificationsSupport.js" type="text/javascript"></script>
    <script src="./Использование ThreadLocal переменных_files/AdminModeSupport.js" type="text/javascript"></script>
    
    <script src="./Использование ThreadLocal переменных_files/FormHandler.js" type="text/javascript"></script>
    <script src="./Использование ThreadLocal переменных_files/highlight.pack.js" type="text/javascript"></script>
    <script src="./Использование ThreadLocal переменных_files/share42.js" type="text/javascript"></script>
    <script src="./Использование ThreadLocal переменных_files/bootbox.min.js" type="text/javascript"></script>
    <script src="./Использование ThreadLocal переменных_files/DeleteLinkHandler.js" type="text/javascript"></script>
    <script src="./Использование ThreadLocal переменных_files/PermalinkSupport.js" type="text/javascript"></script>

    
      <script src="./Использование ThreadLocal переменных_files/uDIma.js" type="text/javascript"></script>
    
    
  


</body></html>